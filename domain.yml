version: "3.1"

intents:
  - greet
  - goodbye
  - ask_mcs_architecture
  - ask_about_ddd
  - ask_what_is_async_interaction_patterns
  - ask_async_interaction_patterns
  - ask_docker
  - ask_architecture_patterns
  - ask_what_is_architecture_patterns
  - ask_patterns_are_used_when_designing_microservices
  - ask_application_level_patterns
  - ask_application_infrastructure_layer_patterns
  - ask_infrastructure_layer_patterns
  - ask_about_some_tech
  - ask_about_containerization
  - ask_about_microservices
  - ask_about_benefits_of_microservices
  - ask_about_build_microservice_architecture
  - ask_about_strangler_fig
  - ask_about_virtualization
  - ask_about_big_bang
  - ask_14_factors_build_microservices

slots:
  some_tech:
    type: text
    mappings:
      - type: from_entity
        entity: some_tech
  related_tech:
    type: text
    mappings:
      - type: from_entity
        entity: related_tech

entities:
  - topic
  - pattern_group
  - some_tech
  - related_tech
  - approach
  - approach_system_refactoring

actions:
  - action_provide_some_tech_info
  - action_provide_async_patterns

responses:
  utter_about_big_bang:
    - text: "
    <p>Миграцию монолита на микросервисы можно провести за один раз. Такой подход называют «Большим взрывом». В рамках этой стратегии компания переносит в микросервисную архитектуру сразу всё приложение. </p>
    <p><strong>«Большой взрыв» относится к антипаттернам</strong>, потому что он сопряжён со значительными рисками. После перехода можно обнаружить такие проблемы:
    <ul>
      <li>ошибки в новой архитектуре привели к длительному простою после релиза,
      <li>новые системы не всегда работают корректно,</li>
      <li>часть информации из монолитной базы данных утеряна,</li>
      <li>микросервисы писали в спешке, поэтому технический долг вырос.</li>
    </ul>
    </p>
    "
  utter_about_virtualization:
    - text: "
      <p><strong>Виртуализация</strong> - ранний подход к изоляции приложений и управлению ими.</p>
      <p><strong>Виртуальные машины (ВМ)</strong> — это виртуальные компьютеры, которые используют ресурсы реального компьютера.</p>
      <p>С помощью виртуализации можно разделить физический сервер на несколько изолированных пространств (ВМ), где можно запускать разные операционные системы. Так можно улучшить использование ресурсов и обеспечить изоляцию приложений.</p>
    "
  utter_about_containerization:
    - text: "
      <p><strong>Контейнеризация</strong> — это технология, которая позволяет упаковать приложение и все его зависимости в единый изолированный контейнер. В отличие от виртуальных машин, контейнеры разделяют ядро операционной системы и используют общие ресурсы — память и процессорное время. Благодаря этому они запускаются быстрее и потребляют меньше ресурсов, чем виртуальные машины.</p>
    "
  utter_about_strangler_fig:
    - text: "
      <p><strong>Strangler Fig</strong> - это подход для постепенной модернизации устаревших систем</p>
      <p>Паттерн Strangler Fig предлагает итеративный подход к миграции. Монолитный бэкенд онлайн-магазина — это дерево-хозяин, а микросервисы — фикус-душитель. Новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы</p>
      <p>Над микросервисами работают без спешки. Новую архитектуру развивают в течение нескольких лет, пока она не «задушит» монолит. При релизе каждого микросервиса разработчики перенаправляют запросы от монолита к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.</p>
      <p>Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.</p>
      <p>Подробнее прочитать о ключевых аспектах и принципах данного подхода можно в [этой статье](https://martinfowler.com/bliki/StranglerFigApplication.html)
    "
  utter_about_build_microservice_architecture:
    - text: "
      <p><strong>Переход на микросервисы — это сложный и ответственный процесс</strong>. Если провести миграцию неправильно, новая архитектура только увеличит количество проблем.</p>
      <p>Самый безопасный вариант — это паттерн <strong>Strangler Fig</strong>. Его задача — максимально сократить риски, которые могут возникнуть во время перехода.</p>
    "

  utter_about_steps_build_microservice_architecture:
    - text: "
      <h2>Как реализовать паттерн Strangler Fig</h2>
      <h4>Шаг 1. Определение доменной области</h4>
      <p>Первым делом для реализации паттерна Strangler Fig нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены.</p>
      <p>На этом этапе команда решает, какой компонент нуждается в извлечении в первую очередь. Это может быть компонент, который: </p>
      <ul>
        <li>Используется наибольшим количеством пользователей,</li>
        <li>работает слишком медленно,</li>
        <li>имеет наименьшее количество зависимостей от других компонентов</li>
      </ul>
      <h4>Шаг 2. Проектирование и разработка новых микросервисов</h4>
      <p>После того как компоненты определены, нужно спроектировать и разработать новые микросервисы. На этом шаге полезно следить за обновлениями в сфере разработки, чтобы перенимать лучшие современные практики.</p>
      
      <h4>Шаг 3. Перенаправление трафика</h4>
      <p>Перенаправление трафика с монолитных компонентов на вновь созданные микросервисы важно для плавного перехода. Стратегий перенаправления трафика существует несколько, и их можно использовать одновременно.</p>
      <ul>
        <li>Маршрутизация на основе прокси</li>
        <li>Фича-тогглы</li>
        <li>Канареечные релизы, или инкрементальное смещение трафика</li>
      </ul>
      <h4>Шаг 4. Мониторинг и верификация микросервисов</h4>
      <p>Четвёртым шагом в паттерне Strangler Fig устанавливаются метрики производительности и настраивается мониторинг и верификация микросервисов.</p>
      <h5>Шаг 5. Настройка итерационного процесса</h5>
      <p>Пятый шаг подразумевает итерационное возвращение к первому пункту и реализацию цикла до тех пор, пока весь монолит не будет заменён</p>
      <p>Этот шаг состоит из настройки трёх процессов: </p>
      <ul>
        <li>непрерывного вычленения компонентов из монолита и замены их микросервисами,</li>
        <li>постепенного улучшения системы,</li>
        <li>координации усилий различных команд.</li>
      </ul>
    "

  utter_14_factors_build_microservices:
    - text: "
      <h3>Для создания микросервисной архитектуры вам понадобится выполнить 14 задач<h3>
      <p>Реализация этих 14ти задач позволит вам создать эффективно работающую микросервисную архитектуру</p>
      <ul>
        <li>Определить границы сервисов</li>
        <li>Определиться с методами взаимодействия микросервисов между собой</li>
        <li>Сформировать стратегию управления данными</li>
        <li>Определить стратегии развёртывания</li>
        <li>Решить задачи балансировки нагрузки</li>
        <li>Обеспечить устойчивость к сбоям</li>
        <li>Определить подходы обеспечению масштабируемости системы</li>
        <li>Решить вопросы безопасности</li>
        <li>Настроить мониторинг работы системы</li>
        <li>Определиться с подходами и технологиями хранения данных</li>
        <li>Настроить API-менеджмент</li>
        <li>Создать систему валидации</li>
        <li>Настроить систему тестирования и валидации</li>
        <li>Внедрить DEVops практики</li>
        <li>Определиться с версионированием</li>
      </ul>
    "

  utter_about_microservices:
    - text: "
      Микросервисная архитектура — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов
    "
  utter_profits_from_microservices:
    - text: "
      В микросервисной архитектуре приложение разбивается на ряд независимо развертываемых сервисов, которые взаимодействуют с помощью API-интерфейсов. Благодаря такому подходу каждый отдельный сервис можно развертывать и масштабировать независимо от других. В результате команды могут быстрее и чаще поставлять объемные и сложные приложения. В отличие от монолитного приложения, с микросервисной архитектурой команды могут быстрее внедрять новые возможности и вносить изменения, при этом им не приходится переписывать большие фрагменты существующего кода.
    "

  utter_infrastructure_layer_patterns:
    - text: "
      <p>Паттерны уровня инфраструктуры помогают координировать взаимодействие микросервисов и управлять их сетевыми взаимодействиями</p>
      <p>Представителями это группы паттернов являются:</p>
      <ul>
        <li><b>Service Discovery</b></li>
        <li><b>Service Mesh</b></li>
        <li><b>Service Registry</b></li>
      </ul>
    "

  utter_application_infrastructure_layer_patterns:
    - text: "
      <p>Паттерны уровня инфраструктуры приложений помогают управлять распределёнными системами, обеспечивая их наблюдаемость и безопасность</p>
      <p>Бывают нескольких видов:</p>
      <ul>
        <li><b>distributed tracing</b> - когда фиксируется движение запроса между всеми микро-сервисами</li>
        <li><b>Audit Logging</b> - когда происходит журналирование всех мутаций данных и состояний, в системе</li>
      </ul>
    "

  utter_greet:
    - text: "Привет! Чем могу помочь?"
    - text: "Привет! Рада вас видеть)"
    - text: "Здравствуйте! Чем могу быть полезна?"

  utter_goodbye:
    - text: "Пока!"
    - text: "Если возникнут вопросы - обращайся!)"
    - text: "Была рада помочь! Если понадоблюсь я здесь)"
    - text: "Было приятно познакомиться! До связи!)"
    - text: "Если будут еще вопросы, дайте знать!)"
    - text: "Всего хорошего! Удачи в делах!"

  utter_mcs_architecture:
    - text: "
      Архитектура ПО это огромный пласт знаний.
      Подходы к проектированию архитектур отличаются в зависимости от платформы и целей программного обеспечения. Однако, есть общие принципы:
      <ul>
        <li>SOLID</li>
        <li>Паттерны проектирования</li>
        <li>Характеристики качества</li>
        <li>Сбор требований</li>
      </ul>
    "

  utter_about_ddd:
    - text: "
    DDD - проектирование, ориентированное на домен.
    <h3>Составные части DDD:</h3>
    <ul>
        <li>Домен - По сути это программное отражение одного из основных направлений деятельности компании</li>
        <li>Поддомен - Кусок функционала со своей предметной областью</li>
        <li>Контекст - это область, внутри которой определённые термины и правила имеют чёткое значение. В DDD контексты помогают избежать путаницы, определяя границы использования понятий.</li>
      </ul>
    "

  utter_what_is_async_interaction_patterns:
    - text: "
      <p><strong>Паттерны асинхронного взаимодействия</strong> - это проверенные и общепринятые подходы к обеспечению взаимодействия между изолированными сервисами. Асинхронное взаимодействие позволяет сервисам отправлять сообщения и события без необходимости немедленного получения ответа. Это осуществляется через брокеры сообщений, очереди или системы событийного взаимодействия.</p>
    "
  utter_interaction_patterns:
    - text: "
    Асинхронное взаимодействие между микросервисами — важная составляющая современных распределённых систем.
    Оно позволяет микросервисам «общаться» без необходимости немедленного ответа, что значительно улучшает масштабируемость и надёжность системы.
    <h3>Для проектирования взаимодействия применяются следующие паттерны:</h3>
    <ul>
        <li>Message Queueing (Очередь сообщений)</li>
        <li>Event Sourcing (Хранение событий)</li>
        <li>Publish/Subscribe (Публикация/Подписка)</li>
        <li>Choreography (Хореография)</li>
        <li>Orchestration (Оркестрация)</li>
      </ul>
    "

  utter_about_docker:
    - text: "
    Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений
    [Подробнее о Docker и пользе его использования для микросервисов здесь](https://practicum.yandex.ru/blog/chto-takoe-docker)
    "

  utter_what_is_architecture_patterns:
    - text: "
          Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
          <h3>Из чего состоит паттерн?</h3>
          <p>Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:</p>
          <ul>
            <li>проблема, которую решает паттерн;</li>
            <li>мотивации к решению проблемы способом, который предлагает паттерн;</li>
            <li>структуры классов, составляющих решение;</li>
            <li>примера на одном из языков программирования;</li>
            <li>особенностей реализации в различных контекстах;</li>
            <li>связей с другими паттернами</li>
          </ul>
        "
  utter_about_architecture_patterns:
    - text: "
      <p>Выделяют три основные группы паттернов:</p>
      <ul>
        <li>Порождающие паттерны - обеспечивают гибкое создание объектов, без внесения изменений в структуру зависимостей</li>
        <li>Структурные паттерны - помогают настраивать связи между объектами </li>
        <li>Поведенческие паттерны - помогают настраивать коммуникации и обмен данными между объектами</li>
      </ul>
    "
  utter_patterns_are_used_when_designing_microservices:
    - text: "
      <p>Существует несколько групп паттернов, которые используются при проектировании микросервисов:</p>
      <ul>
        <li>Паттерны уровня приложения</li>
        <li>Паттерны уровня инфраструктуры приложений</li>
        <li>Паттерны уровня инфраструктуры</li>
      </ul>
      <p>[Дорожную карту по паттернам можно найти тут](https://microservices.io/patterns/)</p>
    "

  utter_application_level_patterns:
    - text: "
      <p>
        Паттерны уровня приложений фокусируются на управлении данными и организации микросервисов. 
        Они помогают создавать независимые, изолированные и хорошо структурированные микросервисы, 
        обеспечивая гибкость и масштабируемость системы.
      </p>
      <p>Подразделяются на несколько групп:</p>
      <ul>
        <li><b>service per team</b> - когда одна команда отвечает за свой микросервис</li>
        <li><b>database per service</b> - у каждого микросервиса своя база данных</li>
        <li><b>Event Sourcing</b> - когда в базе данных хранятся не итоговые состояния, а их история. И каждое состояние можно вычислить путём интеграции всех исторических слепков</li>
      </ul>
    "
session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true
