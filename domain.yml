version: "3.1"

intents:
  - greet
  - goodbye
  - ask_mcs_architecture
  - ask_about_ddd
  - ask_what_is_async_interaction_patterns
  - ask_async_interaction_patterns
  - ask_about_docker
  - ask_architecture_patterns
  - ask_what_is_architecture_patterns
  - ask_patterns_are_used_when_designing_microservices
  - ask_application_level_patterns
  - ask_application_infrastructure_layer_patterns
  - ask_infrastructure_layer_patterns
  - ask_about_some_tech
  - ask_about_containerization
  - ask_about_microservices
  - ask_about_benefits_of_microservices
  - ask_about_build_microservice_architecture
  - ask_about_strangler_fig
  - ask_about_virtualization
  - ask_about_big_bang
  - ask_14_factors_build_microservices
  - ask_about_defined_interaction_pattern
  - ask_about_service_boundaries
  - ask_about_functional_decomposition
  - ask_about_functional_single_responsibility
  - ask_about_kubernetes
  - ask_about_why_use_docker

slots:
  some_tech:
    type: text
    mappings:
      - type: from_entity
        entity: some_tech
  related_tech:
    type: text
    mappings:
      - type: from_entity
        entity: related_tech
  interaction_pattern:
    type: text
    mappings:
      - type: from_entity
        entity: interaction_pattern

entities:
  - topic
  - pattern_group
  - some_tech
  - related_tech
  - approach
  - approach_system_refactoring
  - interaction_pattern
  - decomposition_approach
  - microservices_design_step
  - containerization

actions:
  - action_provide_some_tech_info
  - action_provide_async_patterns
  - action_provide_brokers
  - action_provide_service_boundaries
  - action_provide_containerization

responses:
  utter_about_big_bang:
    - text: "
    <p>Миграцию монолита на микросервисы можно провести за один раз. Такой подход называют «Большим взрывом». В рамках этой стратегии компания переносит в микросервисную архитектуру сразу всё приложение. </p>
    <p><strong>«Большой взрыв» относится к антипаттернам</strong>, потому что он сопряжён со значительными рисками. После перехода можно обнаружить такие проблемы:
    <ul>
      <li>ошибки в новой архитектуре привели к длительному простою после релиза,
      <li>новые системы не всегда работают корректно,</li>
      <li>часть информации из монолитной базы данных утеряна,</li>
      <li>микросервисы писали в спешке, поэтому технический долг вырос.</li>
    </ul>
    </p>
    "
  utter_about_virtualization:
    - text: "
      <p><strong>Виртуализация</strong> - ранний подход к изоляции приложений и управлению ими.</p>
      <p><strong>Виртуальные машины (ВМ)</strong> — это виртуальные компьютеры, которые используют ресурсы реального компьютера.</p>
      <p>С помощью виртуализации можно разделить физический сервер на несколько изолированных пространств (ВМ), где можно запускать разные операционные системы. Так можно улучшить использование ресурсов и обеспечить изоляцию приложений.</p>
    "
  utter_about_containerization:
    - text: "
      <p><strong>Контейнеризация</strong> — это технология, которая позволяет упаковать приложение и все его зависимости в единый изолированный контейнер. В отличие от виртуальных машин, контейнеры разделяют ядро операционной системы и используют общие ресурсы — память и процессорное время. Благодаря этому они запускаются быстрее и потребляют меньше ресурсов, чем виртуальные машины.</p>
    "
  utter_about_strangler_fig:
    - text: "
      <p><strong>Strangler Fig</strong> - это подход для постепенной модернизации устаревших систем</p>
      <p>Паттерн Strangler Fig предлагает итеративный подход к миграции. Монолитный бэкенд онлайн-магазина — это дерево-хозяин, а микросервисы — фикус-душитель. Новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы</p>
      <p>Над микросервисами работают без спешки. Новую архитектуру развивают в течение нескольких лет, пока она не «задушит» монолит. При релизе каждого микросервиса разработчики перенаправляют запросы от монолита к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.</p>
      <p>Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.</p>
      <p>Подробнее прочитать о ключевых аспектах и принципах данного подхода можно в [этой статье](https://martinfowler.com/bliki/StranglerFigApplication.html)
    "
  utter_about_build_microservice_architecture:
    - text: "
      <p><strong>Переход на микросервисы — это сложный и ответственный процесс</strong>. Если провести миграцию неправильно, новая архитектура только увеличит количество проблем.</p>
      <p>Самый безопасный вариант — это паттерн <strong>Strangler Fig</strong>. Его задача — максимально сократить риски, которые могут возникнуть во время перехода.</p>
    "

  utter_about_steps_build_microservice_architecture:
    - text: "
      <h2>Как реализовать паттерн Strangler Fig</h2>
      <h4>Шаг 1. Определение доменной области</h4>
      <p>Первым делом для реализации паттерна Strangler Fig нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены.</p>
      <p>На этом этапе команда решает, какой компонент нуждается в извлечении в первую очередь. Это может быть компонент, который: </p>
      <ul>
        <li>Используется наибольшим количеством пользователей,</li>
        <li>работает слишком медленно,</li>
        <li>имеет наименьшее количество зависимостей от других компонентов</li>
      </ul>
      <h4>Шаг 2. Проектирование и разработка новых микросервисов</h4>
      <p>После того как компоненты определены, нужно спроектировать и разработать новые микросервисы. На этом шаге полезно следить за обновлениями в сфере разработки, чтобы перенимать лучшие современные практики.</p>
      
      <h4>Шаг 3. Перенаправление трафика</h4>
      <p>Перенаправление трафика с монолитных компонентов на вновь созданные микросервисы важно для плавного перехода. Стратегий перенаправления трафика существует несколько, и их можно использовать одновременно.</p>
      <ul>
        <li>Маршрутизация на основе прокси</li>
        <li>Фича-тогглы</li>
        <li>Канареечные релизы, или инкрементальное смещение трафика</li>
      </ul>
      <h4>Шаг 4. Мониторинг и верификация микросервисов</h4>
      <p>Четвёртым шагом в паттерне Strangler Fig устанавливаются метрики производительности и настраивается мониторинг и верификация микросервисов.</p>
      <h5>Шаг 5. Настройка итерационного процесса</h5>
      <p>Пятый шаг подразумевает итерационное возвращение к первому пункту и реализацию цикла до тех пор, пока весь монолит не будет заменён</p>
      <p>Этот шаг состоит из настройки трёх процессов: </p>
      <ul>
        <li>непрерывного вычленения компонентов из монолита и замены их микросервисами,</li>
        <li>постепенного улучшения системы,</li>
        <li>координации усилий различных команд.</li>
      </ul>
    "

  utter_14_factors_build_microservices:
    - text: "
      <h3>Для того чтобы построить у себя микросервисную архитектуру можно воспользоваться дорожной картой из 14ти шагов:</h3>
      <p>Их выполнение позволит вам создать эффективно работающую систему:</p>
      <ul>
        <li>Определить границы сервисов</li>
        <li>Определиться с методами взаимодействия микросервисов между собой</li>
        <li>Сформировать стратегию управления данными</li>
        <li>Определить стратегии развёртывания</li>
        <li>Решить задачи балансировки нагрузки</li>
        <li>Обеспечить устойчивость к сбоям</li>
        <li>Определить подходы обеспечению масштабируемости системы</li>
        <li>Решить вопросы безопасности</li>
        <li>Настроить мониторинг работы системы</li>
        <li>Определиться с подходами и технологиями хранения данных</li>
        <li>Настроить API-менеджмент</li>
        <li>Создать систему валидации</li>
        <li>Настроить систему тестирования и валидации</li>
        <li>Внедрить DEVops практики</li>
        <li>Определиться с версионированием</li>
      </ul>
    "

  utter_about_microservices:
    - text: "
      Микросервисная архитектура — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов
    "
  utter_profits_from_microservices:
    - text: "
      В микросервисной архитектуре приложение разбивается на ряд независимо развертываемых сервисов, которые взаимодействуют с помощью API-интерфейсов. Благодаря такому подходу каждый отдельный сервис можно развертывать и масштабировать независимо от других. В результате команды могут быстрее и чаще поставлять объемные и сложные приложения. В отличие от монолитного приложения, с микросервисной архитектурой команды могут быстрее внедрять новые возможности и вносить изменения, при этом им не приходится переписывать большие фрагменты существующего кода.
    "

  utter_infrastructure_layer_patterns:
    - text: "
      <p>Паттерны уровня инфраструктуры помогают координировать взаимодействие микросервисов и управлять их сетевыми взаимодействиями</p>
      <p>Представителями это группы паттернов являются:</p>
      <ul>
        <li><b>Service Discovery</b></li>
        <li><b>Service Mesh</b></li>
        <li><b>Service Registry</b></li>
      </ul>
    "

  utter_application_infrastructure_layer_patterns:
    - text: "
      <p>Паттерны уровня инфраструктуры приложений помогают управлять распределёнными системами, обеспечивая их наблюдаемость и безопасность</p>
      <p>Бывают нескольких видов:</p>
      <ul>
        <li><b>distributed tracing</b> - когда фиксируется движение запроса между всеми микро-сервисами</li>
        <li><b>Audit Logging</b> - когда происходит журналирование всех мутаций данных и состояний, в системе</li>
      </ul>
    "

  utter_greet:
    - text: "Привет! Чем могу помочь?"
    - text: "Привет! Рада вас видеть)"
    - text: "Здравствуйте! Чем могу быть полезна?"

  utter_goodbye:
    - text: "Пока!"
    - text: "Если возникнут вопросы - обращайся!)"
    - text: "Была рада помочь! Если понадоблюсь я здесь)"
    - text: "Было приятно познакомиться! До связи!)"
    - text: "Если будут еще вопросы, дайте знать!)"
    - text: "Всего хорошего! Удачи в делах!"

  utter_mcs_architecture:
    - text: "
      Архитектура ПО это огромный пласт знаний.
      Подходы к проектированию архитектур отличаются в зависимости от платформы и целей программного обеспечения. Однако, есть общие принципы:
      <ul>
        <li>SOLID</li>
        <li>Паттерны проектирования</li>
        <li>Характеристики качества</li>
        <li>Сбор требований</li>
      </ul>
    "
  utter_about_functional_decomposition:
    - text: "
      <p><strong>Функциональная декомпозиция</strong> - это подход к разбивке монолитного приложения на микросервисы</p>
      <p>При его реализации команда, опираясь на показатели работы системы и узкие места расставляет приоритеты по извлечению функциональности из монолита</p>
      <p>Самые проблемные участки системы или узкие места - извлекаются первыми. Затем менее проблемные и т.д...</p>
    "
  utter_about_ddd:
    - text: "
    DDD - проектирование, ориентированное на домен.
    <h3>Составные части DDD:</h3>
    <ul>
        <li>Домен - По сути это программное отражение одного из основных направлений деятельности компании</li>
        <li>Поддомен - Кусок функционала со своей предметной областью</li>
        <li>Контекст - это область, внутри которой определённые термины и правила имеют чёткое значение. В DDD контексты помогают избежать путаницы, определяя границы использования понятий.</li>
      </ul>
    "
  utter_about_single_responsibility:
    - text: "
      <p><strong>Принцип единой ответственности</strong> - это подход к разбивке монолитного приложения на микросервисы, в основе которого в микросервис попадает только та часть кода, которая реализует строго одну, конкретную функциональность или бизнес-задачу</p>
    "

  utter_what_is_async_interaction_patterns:
    - text: "
      <p><strong>Паттерны асинхронного взаимодействия</strong> - это проверенные и общепринятые подходы к обеспечению взаимодействия между изолированными сервисами. Асинхронное взаимодействие позволяет сервисам отправлять сообщения и события без необходимости немедленного получения ответа. Это осуществляется через брокеры сообщений, очереди или системы событийного взаимодействия.</p>
    "
  utter_interaction_patterns:
    - text: "
    Асинхронное взаимодействие между микросервисами — важная составляющая современных распределённых систем.
    Оно позволяет микросервисам «общаться» без необходимости немедленного ответа, что значительно улучшает масштабируемость и надёжность системы.
    <h3>Для проектирования взаимодействия применяются следующие паттерны:</h3>
    <ul>
        <li>Message Queueing (Очередь сообщений)</li>
        <li>Event Sourcing (Хранение событий)</li>
        <li>Publish/Subscribe (Публикация/Подписка)</li>
        <li>Choreography (Хореография)</li>
        <li>Orchestration (Оркестрация)</li>
      </ul>
    "

  utter_about_docker:
    - text: "
        Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений
        [Подробнее о Docker и пользе его использования для микросервисов здесь](https://practicum.yandex.ru/blog/chto-takoe-docker)
    "

  utter_about_why_use_docker:
    - text: "
        <p>Использование Docker при создании микросервисной архитектуры имеет множество преимуществ. Docker упрощает разработку, развёртывание и масштабирование микросервисов, делая процесс более эффективным и предсказуемым</p>
        <p>Использование Docker при создании микросервисов помогает решить ряд задач:
        <ul>
          <li><strong>Изоляция микросервисов</strong> - Каждый микросервис работает в своём собственном контейнере, что обеспечивает изоляцию</li>
          <li><strong>Портируемость</strong> - Docker-контейнеры могут быть легко перенесены между различными средами</li>
          <li><strong>Масштабируемость</strong> - Docker упрощает масштабирование микросервисов</li>
          <li><strong>Упрощение CI/CD</strong> - Docker интегрируется с системами непрерывной интеграции и доставки (CI/CD)</li>
          <li><strong>Эффективное использование ресурсов</strong> - Контейнеры используют ресурсы более эффективно, чем виртуальные машины</li>
          <li><strong> Упрощение управления зависимостями</strong> - Каждый микросервис может иметь свои собственные зависимости, упакованные в контейнер. Т.о. нет необходимости устанавливать все зависимости на одной машине, зависимости могут быть обновлены в одном контейнере без влияния на другие микросервисы.</li>
        </ul>
    "

  utter_about_kubernetes:
    - text: "
        <p><strong>Kubernetes (часто сокращённо называют K8s)</strong> — это открытая платформа для автоматизации развёртывания, масштабирования и управления контейнеризированными приложениями. Он был разработан компанией Google и сейчас поддерживается Cloud Native Computing Foundation (CNCF)</p>
        <p>Используется для построения больших микросервисных архитектур для управления жизненным циклом сервисов, быстрого масштабирования, при высоких нагрузках</p>
        <p><strong>Преимущества Kubernetes:</strong></p>
        <ul>
          <li>Портативность: Приложения, развёрнутые в Kubernetes, могут работать на любом облаке или локальном кластере.</li>
          <li>Масштабируемость: Легко масштабировать приложения в зависимости от нагрузки.</li>
          <li>Автоматизация: Kubernetes автоматически управляет контейнерами, что снижает нагрузку на администраторов.</li>
          <li>Экосистема: Большое количество инструментов и плагинов для интеграции с другими системами</li>
        </ul>
    "

  utter_what_is_architecture_patterns:
    - text: "
          Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
          <h3>Из чего состоит паттерн?</h3>
          <p>Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:</p>
          <ul>
            <li>проблема, которую решает паттерн;</li>
            <li>мотивации к решению проблемы способом, который предлагает паттерн;</li>
            <li>структуры классов, составляющих решение;</li>
            <li>примера на одном из языков программирования;</li>
            <li>особенностей реализации в различных контекстах;</li>
            <li>связей с другими паттернами</li>
          </ul>
        "
  utter_about_architecture_patterns:
    - text: "
      <p>Выделяют три основные группы паттернов:</p>
      <ul>
        <li>Порождающие паттерны - обеспечивают гибкое создание объектов, без внесения изменений в структуру зависимостей</li>
        <li>Структурные паттерны - помогают настраивать связи между объектами </li>
        <li>Поведенческие паттерны - помогают настраивать коммуникации и обмен данными между объектами</li>
      </ul>
    "
  utter_patterns_are_used_when_designing_microservices:
    - text: "
      <p>Существует несколько групп паттернов, которые используются при проектировании микросервисов:</p>
      <ul>
        <li>Паттерны уровня приложения</li>
        <li>Паттерны уровня инфраструктуры приложений</li>
        <li>Паттерны уровня инфраструктуры</li>
      </ul>
      <p>[Дорожную карту по паттернам можно найти тут](https://microservices.io/patterns/)</p>
    "

  utter_application_level_patterns:
    - text: "
      <p>
        Паттерны уровня приложений фокусируются на управлении данными и организации микросервисов. 
        Они помогают создавать независимые, изолированные и хорошо структурированные микросервисы, 
        обеспечивая гибкость и масштабируемость системы.
      </p>
      <p>Подразделяются на несколько групп:</p>
      <ul>
        <li><b>service per team</b> - когда одна команда отвечает за свой микросервис</li>
        <li><b>database per service</b> - у каждого микросервиса своя база данных</li>
        <li><b>Event Sourcing</b> - когда в базе данных хранятся не итоговые состояния, а их история. И каждое состояние можно вычислить путём интеграции всех исторических слепков</li>
      </ul>
    "
session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true
